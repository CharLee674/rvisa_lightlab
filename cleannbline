#!/usr/bin/env python

''' Cleans up the first line of .ipynb (JSON) files
    that have been corrupted.

    See help (cleannbline -h) for usage instructions
'''

import fileinput
import sys
import os
import argparse
from subprocess import call
import shutil

maxRecursion = 10
validFileTypes = ['ipynb']

parser = argparse.ArgumentParser(description="Cleans up the first line of .ipynb (JSON) files that have been corrupted.")
parser.add_argument("files", nargs="+",
                    help="files, globs, or wildcards to clean")
parser.add_argument("-r", "--recursion", nargs='?', const=maxRecursion, default=0, type=int,
                    help="descend this many levels (default=0; flag but no argument=10)")
parser.add_argument("-v", "--verbose", action="store_true",
                    help="echo the file names being cleaned")
parser.add_argument("-n", "--dryrun", action="store_true",
                    help="echo file names but do not perform cleaning")
args = parser.parse_args()
if args.dryrun:
    args.verbose = True

subDirs = []

for fi in args.files:
    if os.path.isdir(fi):
        subDirs.append(fi)
    elif fi.split('.')[-1] not in validFileTypes:
        pass
    elif os.path.islink(fi):  # If file is just a symbolic link
        pass
    else:
        if args.dryrun:
            print('Would clean {}'.format(fi))
        else:
            if args.verbose:
                print('Cleaning {}'.format(fi))
            ## fast version [Not working]: It only reads the first line instead of iterating through all
            # with open(fi) as from_file:
            #     line = from_file.readline() # all this does is move the write head. It's important!
            #     with open(fi,mode="w") as to_file:
            #         to_file.write('{\n')
            #         shutil.copyfile(from_file, to_file)
            ## working version
            for line_number, line in enumerate(fileinput.input(fi, inplace=True)):
                if line_number == 0:
                    sys.stdout.write('{\n')
                else:
                    sys.stdout.write(line)

for d in subDirs:
    if args.verbose:
        print('--' * (1 + args.recursion) + '> ' + d)
    if args.recursion == 0:
        if args.verbose:
            print('End recursion')
    else:
        subCallArgs = [sys.argv[0]]
        subCallArgs += ['-r', str(args.recursion - 1)]
        if args.dryrun:
            subCallArgs += ['-n']
        subCallArgs += [d + '/*']
        call(' '.join(subCallArgs), shell=True)
